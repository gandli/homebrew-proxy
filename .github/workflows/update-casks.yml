---
name: Update Casks

"on":
  schedule:
    - cron: 0 2 * * *
  workflow_dispatch: {}
  push:
    paths:
      - 'Casks/*.rb'
    branches:
      - main

# 防止并发执行，避免API速率限制冲突
concurrency:
  group: update-casks
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 60  # 设置超时时间
    # 避免循环触发：排除由 GitHub Actions 自动提交的推送
    if: github.actor != 'github-actions[bot]'
    steps:
      - uses: actions/checkout@v4

      # 缓存Ruby依赖
      - name: Cache Ruby dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gem
            vendor/bundle
          key: ${{ runner.os }}-ruby-3.0-${{ hashFiles('**/Gemfile.lock', '**/gems.locked') }}
          restore-keys: |
            ${{ runner.os }}-ruby-3.0-
            ${{ runner.os }}-ruby-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.0'
          bundler-cache: true  # 自动缓存bundler依赖

      - name: Update all casks
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          # 智能资源文件匹配函数
          find_matching_asset() {
            local latest_release="$1"
            local base_name="$2"
            local file_ext="$3"
            
            echo "🔍 开始智能多轮回退匹配策略..." >&2
            
            # 提取应用名称（去除连字符，转换为点分隔）
            local app_name
            app_name=$(echo "$base_name" | sed -E 's/-([a-z])/\U\1/g' | sed -E 's/^([a-z])/\U\1/')
            
            # 获取当前架构
            local current_arch="aarch64"  # GitHub Actions 默认为 x64，但我们优先匹配 Apple Silicon
            
            # 构建多种搜索策略
            local strategies=(
              # 策略1：基于应用名称的精确匹配
              "cask_original:$base_name"
              # 策略2：基于应用名称的点分隔匹配
              "cask_dots:$(echo "$base_name" | sed 's/-/\./g')"
              # 策略3：部分名称匹配（去除常见后缀）
              "partial_dots:$(echo "$base_name" | sed -E 's/-(rev|party|meta|pro|plus)$//' | sed 's/-/\./g')"
              # 策略4：应用名称匹配
              "app_name:$app_name"
              # 策略5：架构特定匹配
              "arch_specific:$current_arch"
            )
            
            # 多轮匹配执行
            for strategy in "${strategies[@]}"; do
              local strategy_type="${strategy%%:*}"
              local search_term="${strategy#*:}"
              
              echo "🎯 尝试策略: $strategy_type -> $search_term" >&2
              
              local download_url=""
              
              case "$strategy_type" in
                 "cask_original")
                    # 优先匹配当前架构（大小写不敏感）
                    download_url=$(echo "$latest_release" | \
                      jq -r --arg term "$search_term" --arg arch "$current_arch" --arg ext "$file_ext" \
                        '.assets[] | select(.name | test(".*" + $term + ".*_" + $arch + "\\." + $ext; "i")) | .browser_download_url' | head -1)
                    if [[ -z "$download_url" || "$download_url" == "null" ]]; then
                      # 通用匹配（大小写不敏感）
                      download_url=$(echo "$latest_release" | \
                        jq -r --arg term "$search_term" --arg ext "$file_ext" \
                          '.assets[] | select(.name | test(".*" + $term + ".*\\." + $ext; "i")) | .browser_download_url' | head -1)
                    fi
                    ;;
                  "cask_dots"|"partial_dots")
                    # 优先匹配当前架构（大小写不敏感）
                    download_url=$(echo "$latest_release" | \
                      jq -r --arg term "$search_term" --arg arch "$current_arch" --arg ext "$file_ext" \
                        '.assets[] | select(.name | test(".*" + $term + ".*_" + $arch + "\\." + $ext; "i")) | .browser_download_url' | head -1)
                    if [[ -z "$download_url" || "$download_url" == "null" ]]; then
                      # 通用匹配（大小写不敏感）
                      download_url=$(echo "$latest_release" | \
                        jq -r --arg term "$search_term" --arg ext "$file_ext" \
                          '.assets[] | select(.name | test(".*" + $term + ".*\\." + $ext; "i")) | .browser_download_url' | head -1)
                    fi
                    ;;
                  "app_name")
                    # 应用名称匹配（大小写不敏感）
                    download_url=$(echo "$latest_release" | \
                      jq -r --arg term "$search_term" --arg ext "$file_ext" \
                        '.assets[] | select(.name | test(".*" + $term + ".*\\." + $ext; "i")) | .browser_download_url' | head -1)
                    ;;
                  "arch_specific")
                    # 架构特定匹配（大小写不敏感）
                    download_url=$(echo "$latest_release" | \
                      jq -r --arg term "$search_term" --arg ext "$file_ext" \
                        '.assets[] | select(.name | test(".*_" + $term + "\\." + $ext; "i")) | .browser_download_url' | head -1)
                    ;;
              esac
              
              if [[ -n "$download_url" && "$download_url" != "null" ]]; then
                local matched_file
                matched_file=$(echo "$latest_release" | \
                  jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
                echo "✅ 策略 $strategy_type 成功匹配: $matched_file" >&2
                echo "$download_url"
                return 0
              fi
            done
            
            echo "❌ 所有智能匹配策略都失败了" >&2
            return 1
          }

          # 从 cask 文件中提取 GitHub 仓库信息的函数
          extract_repo_info() {
            local cask_file="$1"

            # 提取 homepage URL (GitHub 仓库)
            local homepage
            homepage=$(grep -E '^\s*homepage\s+"' "$cask_file" | sed -E 's/.*homepage\s+"([^"]+)".*/\1/')

            # 如果 homepage 不是 GitHub，尝试从 URL 中提取
            if [[ "$homepage" != *"github.com"* ]]; then
              homepage=$(grep -E '^\s*url\s+"' "$cask_file" | \
                sed -E 's/.*"https:\/\/github\.com\/([^\/]+\/[^\/]+)\/.*/https:\/\/github.com\/\1/' | head -1)
            fi

            # 提取 URL 模式来推断资源文件名
            local url_line
            url_line=$(grep -E '^\s*url\s+"' "$cask_file" | head -1)
            local asset_pattern=""

            # 通用的资源文件名推断逻辑
            # 从 URL 中提取文件名模式，支持版本和架构变量替换
            if [[ "$url_line" =~ url[[:space:]]+\"([^\"]+)\" ]]; then
              local url_template
              url_template="${BASH_REMATCH[1]}"

              # 提取文件名部分（最后一个 / 之后的内容）
              local filename
              filename=$(echo "$url_template" | sed -E 's/.*\///')

              echo "📋 提取的文件名模板: $filename" >&2

              # 处理不同的文件名模式
              if [[ "$filename" == *"#{"* ]]; then
                # 包含变量的情况，替换为通用模式
                asset_pattern="$filename"

                # 替换版本变量
                asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{version\}/[0-9]+\.[0-9]+\.[0-9]+/g')

                # 处理架构变量
                if [[ "$asset_pattern" == *"#{arch}"* ]]; then
                  # 对于有架构变量的情况，创建一个更宽泛的模式
                  asset_pattern=$(echo "$asset_pattern" | \
                    sed -E 's/#\{arch\}/(aarch64|arm64|x64|x86_64)/g')
                elif [[ "$asset_pattern" == *"_aarch64"* || "$asset_pattern" == *"_x64"* ]]; then
                  # 处理固定架构的情况
                  asset_pattern=$(echo "$asset_pattern" | \
                    sed -E 's/_(aarch64|x64)/_(aarch64|arm64|x64|x86_64)/g')
                fi

                # 转义正则表达式特殊字符
                asset_pattern=$(echo "$asset_pattern" | sed -E 's/\./\\./g')

                # 调试输出：显示完整的模式生成过程
                echo "🔧 原始文件名: $filename" >&2
                echo "🔧 处理后的模式: $asset_pattern" >&2
                echo "🔧 模式长度: ${#asset_pattern}" >&2
              else
                # 固定文件名的情况（如 Hiddify-MacOS.dmg）
                asset_pattern=$(echo "$filename" | sed -E 's/\./\\./g')
              fi

              echo "🎯 生成的资产模式: $asset_pattern" >&2

              # 检查模式长度，防止截断
              if [[ ${#asset_pattern} -lt 10 ]]; then
                echo "⚠️  资产模式似乎太短，可能被截断: '$asset_pattern'" >&2
              fi
            else
              echo "⚠️  无法从以下内容提取 URL 模式: $url_line" >&2
              asset_pattern=""
            fi

            # 确保完整输出，防止截断
            if [[ -n "$homepage" && -n "$asset_pattern" ]]; then
              printf "%s|%s\n" "$homepage" "$asset_pattern"
            else
              echo "$homepage|$asset_pattern"
            fi
          }

          # 处理非 GitHub 仓库的通用更新逻辑
          update_non_github_cask() {
            local cask_file="$1"
            echo "🌐 处理非 GitHub 仓库: $cask_file"
            
            local cask_name
            cask_name=$(basename "$cask_file" .rb)
            
            # 检查是否有 livecheck 配置
            if ! grep -q 'livecheck do' "$cask_file"; then
              echo "ℹ️  $cask_name 没有 livecheck 配置，跳过更新"
              return
            fi
            
            # 提取 livecheck 策略
            local livecheck_strategy
            livecheck_strategy=$(grep -A 10 'livecheck do' "$cask_file" | grep -E 'strategy\s+:' | \
              sed -E 's/.*strategy\s+:([a-zA-Z_]+).*/\1/' | head -1)
            
            echo "🔍 检测到 livecheck 策略: $livecheck_strategy"
            
            case "$livecheck_strategy" in
              "sparkle")
                handle_sparkle_update "$cask_file" "$cask_name"
                ;;
              "page_match")
                handle_page_match_update "$cask_file" "$cask_name"
                ;;
              *)
                echo "ℹ️  暂不支持 $livecheck_strategy 策略，跳过更新"
                ;;
            esac
          }
          
          # 处理 Sparkle feed 更新
          handle_sparkle_update() {
            local cask_file="$1"
            local cask_name="$2"
            
            echo "🔍 使用 Sparkle 策略获取更新信息"
            
            # 提取当前版本
            local current_version
            current_version=$(grep -E '^\s*version\s+' "$cask_file" | head -1 | \
              sed -E 's/.*version\s+"([^"]+)".*/\1/')
            
            echo "📋 当前版本: $current_version"
            
            # 获取 Sparkle feed URL
            local sparkle_url
            sparkle_url=$(grep -A 10 'livecheck do' "$cask_file" | grep -E 'url\s+".*xml"' | \
              sed -E 's/.*url\s+"([^"]+)".*/\1/')
            
            if [[ -n "$sparkle_url" ]]; then
              # 替换版本变量（通用处理）
              if [[ "$sparkle_url" == *"#{version.major}"* ]]; then
                local major_version
                major_version=$(echo "$current_version" | cut -d',' -f1 | cut -d'.' -f1)
                sparkle_url=$(echo "$sparkle_url" | sed "s/#{version.major}/$major_version/g")
              fi
              
              echo "🔗 Sparkle feed URL: $sparkle_url"
              
              # 获取 Sparkle feed 内容
              local feed_content
              feed_content=$(curl -s "$sparkle_url" 2>/dev/null)
              
              if [[ -n "$feed_content" ]]; then
                echo "📄 成功获取 Sparkle feed 内容"
                
                # 从 XML 中提取最新的 enclosure URL（通用匹配）
                local latest_url
                latest_url=$(echo "$feed_content" | grep -o 'url="[^"]*\.(zip|dmg|pkg)"' | head -1 | sed 's/url="//;s/"//')
                
                if [[ -n "$latest_url" ]]; then
                  echo "🔗 找到最新下载链接: $latest_url"
                  
                  # 通用版本提取逻辑
                  local new_version
                  new_version=$(extract_version_from_url "$latest_url" "$current_version")
                  
                  if [[ -n "$new_version" && "$new_version" != "$current_version" ]]; then
                    echo "📦 发现新版本: $current_version → $new_version"
                    
                    # 下载并计算 SHA256
                    echo "📥 正在下载并计算 SHA256..."
                    local sha256
                    sha256=$(curl -sL --fail "$latest_url" | shasum -a 256 | awk '{print $1}')
                    
                    if [[ -n "$sha256" && ${#sha256} -eq 64 ]]; then
                      echo "🔒 计算的 SHA256: $sha256"
                      
                      # 更新 cask 文件
                      sed -i "s/version \".*\"/version \"$new_version\"/" "$cask_file"
                      sed -i "s/sha256 \".*\"/sha256 \"$sha256\"/" "$cask_file"
                      
                      echo "✅ 成功更新 $cask_name"
                      echo "📝 版本更新: $current_version → $new_version"
                    else
                      echo "❌ 计算 SHA256 失败"
                    fi
                  else
                    echo "ℹ️  $cask_name 已是最新版本或无法解析版本"
                  fi
                else
                  echo "⚠️  无法从 Sparkle feed 中提取下载链接"
                fi
              else
                echo "⚠️  无法获取 Sparkle feed 内容"
              fi
            else
              echo "⚠️  未找到 Sparkle feed URL"
            fi
          }
          
          # 处理页面匹配更新
          handle_page_match_update() {
            local cask_file="$1"
            local cask_name="$2"
            
            echo "🔍 使用页面匹配策略获取更新信息"
            echo "ℹ️  页面匹配策略暂未实现，跳过 $cask_name"
          }
          
          # 从 URL 中提取版本信息的通用函数
          extract_version_from_url() {
            local url="$1"
            local current_version="$2"
            
            # 提取文件名
            local filename
            filename=$(basename "$url")
            
            # 尝试多种版本匹配模式
            local version_patterns=(
              # 模式1: App-x.x.x-xxxx-hash.zip (如 Surge)
              's/.*-([0-9]+\.[0-9]+\.[0-9]+)-([0-9]+)-([a-f0-9]+)\..*/\1,\2,\3/'
              # 模式2: App-x.x.x.zip
              's/.*-([0-9]+\.[0-9]+\.[0-9]+)\..*/\1/'
              # 模式3: App_x.x.x.zip
              's/.*_([0-9]+\.[0-9]+\.[0-9]+)\..*/\1/'
              # 模式4: Appx.x.x.zip
              's/.*([0-9]+\.[0-9]+\.[0-9]+)\..*/\1/'
            )
            
            for pattern in "${version_patterns[@]}"; do
              local extracted_version
              extracted_version=$(echo "$filename" | sed -E "$pattern")
              
              # 检查是否成功提取到版本（不等于原文件名）
              if [[ "$extracted_version" != "$filename" && -n "$extracted_version" ]]; then
                echo "$extracted_version"
                return 0
              fi
            done
            
            echo "" # 未找到版本
            return 1
          }

          # 更新单个 cask 文件的函数
          update_cask() {
            local cask_file="$1"
            local repo_url="$2"
            local asset_pattern="$3"

            echo "🔄 正在处理 $cask_file..."

            # 检查是否为 GitHub 仓库
            if [[ "$repo_url" == *"github.com"* && -n "$asset_pattern" ]]; then
              owner_repo=$(echo "$repo_url" | sed -e 's|https://github.com/||' -e 's|/$||')

              # 获取最新版本信息（带重试机制和速率限制处理）
              echo "正在获取 $owner_repo 的最新版本..."

              # 智能API速率限制管理
              check_and_handle_rate_limit() {
                local min_remaining=${1:-20}  # 最小剩余请求数
                local rate_limit_check
                local remaining
                local reset_time
                local current_time
                local wait_time

                rate_limit_check=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/rate_limit")
                remaining=$(echo "$rate_limit_check" | jq -r '.rate.remaining // 0')

                echo "📊 API剩余请求数: $remaining" >&2

                if [[ "$remaining" -lt "$min_remaining" ]]; then
                  reset_time=$(echo "$rate_limit_check" | jq -r '.rate.reset // 0')
                  current_time=$(date +%s)
                  wait_time=$((reset_time - current_time + 60))

                  if [[ $wait_time -gt 0 && $wait_time -lt 3600 ]]; then
                    echo "⏳ API速率限制即将耗尽，智能等待 $wait_time 秒..." >&2
                    sleep $wait_time
                    return 0
                  else
                    echo "⚠️  API速率限制耗尽且重置时间异常，跳过当前操作" >&2
                    return 1
                  fi
                fi

                # 添加请求间隔，避免过于频繁的API调用
                sleep 2
                return 0
              }

              # 检查API速率限制
              if ! check_and_handle_rate_limit 15; then
                echo "❌ API速率限制处理失败，跳过 $cask_file" >&2
                return
              fi

              # 首先检查仓库是否存在或已重定向
              repo_check=$(curl -s -I -H "Authorization: token $GITHUB_TOKEN" \
                "https://api.github.com/repos/$owner_repo")

              if [[ "$repo_check" == *"301 Moved Permanently"* || "$repo_check" == *"302 Found"* ]]; then
                echo "⚠️  仓库 $owner_repo 已被移动或重命名" >&2

                # 尝试获取新的仓库地址
                new_location=$(echo "$repo_check" | grep -i "location:" | sed 's/.*location: *//i' | tr -d '\r')
                if [[ -n "$new_location" && "$new_location" == *"github.com"* ]]; then
                  new_owner_repo=$(echo "$new_location" | \
                    sed -E 's|.*github.com/([^/]+/[^/]+).*|\1|')
                  echo "🔄 尝试新仓库: $new_owner_repo" >&2
                  owner_repo="$new_owner_repo"
                else
                  echo "❌ 无法确定 $cask_file 的新仓库位置" >&2
                  return
                fi
              fi

              # 智能API请求重试机制
              make_api_request() {
                local url="$1"
                local max_retries=5
                local retry_count=0
                local backoff_base=3
                local response

                while [[ $retry_count -lt $max_retries ]]; do
                  # 在每次请求前检查速率限制
                  if ! check_and_handle_rate_limit 10; then
                    echo "❌ API速率限制检查失败，终止请求" >&2
                    return 1
                  fi

                  echo "📡 发起API请求 (尝试 $((retry_count + 1))/$max_retries): $url" >&2
                  response=$(curl -s -w "HTTP_CODE:%{http_code}" \
                    -H "Authorization: token $GITHUB_TOKEN" "$url")

                  local http_code
                  http_code=$(echo "$response" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
                  local body
                  body=$(echo "$response" | sed 's/HTTP_CODE:[0-9]*$//')

                  # 根据HTTP状态码判断是否需要重试
                  case "$http_code" in
                    200)
                      # 成功响应，检查内容是否有效
                      if [[ -n "$body" && "$body" != *"rate limit"* && \
                            "$body" != *"Not Found"* ]]; then
                        echo "$body"
                        return 0
                      fi
                      ;;
                    403)
                      # 可能是速率限制，等待更长时间
                      echo "⚠️  收到403响应，可能触发速率限制" >&2
                      if ! check_and_handle_rate_limit 5; then
                        return 1
                      fi
                      ;;
                    404)
                      # 资源不存在，不需要重试
                      echo "❌ 资源不存在 (404): $url" >&2
                      return 1
                      ;;
                    301|302)
                      # 重定向，尝试获取新位置
                      echo "🔄 检测到重定向 ($http_code)" >&2
                      ;;
                    *)
                      echo "⚠️  收到意外HTTP状态码: $http_code" >&2
                      ;;
                  esac

                  retry_count=$((retry_count + 1))
                  if [[ $retry_count -lt $max_retries ]]; then
                    local wait_time
                    wait_time=$((backoff_base ** retry_count))
                    echo "⏳ 请求失败，指数退避等待 $wait_time 秒后重试..." >&2
                    sleep $wait_time
                  fi
                done

                echo "❌ API请求最终失败，已达到最大重试次数" >&2
                return 1
              }

              # 使用智能请求机制获取最新版本
              latest_release=$(make_api_request \
                "https://api.github.com/repos/$owner_repo/releases/latest")

              if [[ -z "$latest_release" || "$latest_release" == *"rate limit"* || \
                    "$latest_release" == *"Not Found"* ]]; then
                echo "❌ GitHub API 请求失败或达到速率限制 $cask_file (仓库: $owner_repo)" >&2
                return
              fi

              latest_version=$(echo "$latest_release" | jq -r '.tag_name' | sed 's/^v//')

              if [[ "$latest_version" == "null" || -z "$latest_version" ]]; then
                echo "❌ 获取 $cask_file 最新版本失败 (仓库: $owner_repo)" >&2
                echo "API 响应: $(echo "$latest_release" | jq -r '.message // "无消息"')" >&2

                # 如果是 hiddify，尝试使用新的仓库名
                if [[ "$owner_repo" == *"hiddify"* && "$owner_repo" == *"hiddify-next"* ]]; then
                  echo "🔄 尝试 hiddify 的备用仓库名..." >&2
                  owner_repo="hiddify/hiddify-app"
                  latest_release=$(curl -s \
                    "https://api.github.com/repos/$owner_repo/releases/latest")
                  latest_version=$(echo "$latest_release" | jq -r '.tag_name' | sed 's/^v//')

                  if [[ "$latest_version" != "null" && -n "$latest_version" ]]; then
                    echo "✅ 在备用仓库中找到版本: $owner_repo" >&2
                  else
                    echo "❌ 备用仓库也失败了" >&2
                    return
                  fi
                else
                  return
                fi
              fi

              echo "找到最新版本: $latest_version"

              # 获取匹配的资源文件
               echo "搜索匹配模式的资产: $asset_pattern"

               # 列出所有可用的资源文件用于调试
               echo "可用资产:"
               echo "$latest_release" | jq -r '.assets[].name' | sed 's/^/  - /'

               # 通用的资源文件匹配逻辑
               # 首先尝试完全匹配模式（修复 jq 转义问题）
               # 对于固定文件名（如 Hiddify-MacOS.dmg），使用精确匹配
               if [[ "$asset_pattern" =~ ^[A-Za-z0-9._-]+\\\.[a-z]+$ ]]; then
                 # 固定文件名，使用精确匹配
                 fixed_name=${asset_pattern//\\./.}
                 download_url=$(echo "$latest_release" | \
                   jq -r ".assets[] | select(.name == \"$fixed_name\") | .browser_download_url" | head -1)
                 echo "🎯 对固定文件名使用精确匹配: $fixed_name"
               else
                 # 使用正则表达式匹配
                 echo "🎯 使用正则表达式匹配: $asset_pattern" >&2
                 # 对 asset_pattern 进行适当的转义处理，避免 shell 转义问题
                 escaped_pattern=$(printf '%s' "$asset_pattern" | sed 's/\\/\\\\/g')
                 download_url=$(echo "$latest_release" | \
                   jq -r --arg pattern "$escaped_pattern" '.assets[] | select(.name | test($pattern)) | .browser_download_url' | head -1)

                 # 如果正则匹配失败，尝试更简单的模式
                 if [[ -z "$download_url" || "$download_url" == "null" ]]; then
                   echo "🔄 正则匹配失败，尝试简化模式..." >&2
                   # 移除复杂的正则表达式，使用更简单的匹配
                   simple_pattern=$(echo "$asset_pattern" | sed -E 's/\\\././g' | \
                     sed -E 's/\[0-9\]\+\\\.[0-9\]\+\\\.[0-9\]\+/[0-9.]*/g' | \
                     sed -E 's/\([^)]*\)/*/g')
                   echo "🎯 简化后的模式: $simple_pattern" >&2
                   download_url=$(echo "$latest_release" | \
                     jq -r ".assets[] | select(.name | contains(\"$simple_pattern\")) | .browser_download_url" | \
                     head -1)
                 fi
               fi

               # 如果没有找到匹配的资源，尝试智能匹配
                if [[ -z "$download_url" || "$download_url" == "null" ]]; then
                  echo "未找到精确匹配，启动智能多轮回退匹配策略..."

                  # 从原始文件名中提取基本信息
                  local base_name
                  base_name=$(basename "$cask_file" .rb)
                  local file_ext=""

                  # 从 asset_pattern 中推断文件扩展名
                  if [[ "$asset_pattern" == *".dmg"* ]]; then
                    file_ext="dmg"
                  elif [[ "$asset_pattern" == *".zip"* ]]; then
                    file_ext="zip"
                  elif [[ "$asset_pattern" == *".pkg"* ]]; then
                    file_ext="pkg"
                  else
                    file_ext="(dmg|zip|pkg)"
                  fi

                  echo "启动智能匹配 base_name: $base_name, file_ext: $file_ext"

                  # 调用智能匹配函数
                  download_url=$(find_matching_asset "$latest_release" "$base_name" "$file_ext")

                  if [[ -n "$download_url" && "$download_url" != "null" ]]; then
                    local matched_asset
                    matched_asset=$(echo "$latest_release" | \
                      jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
                    echo "🎉 智能匹配成功找到资产: $matched_asset"
                  fi
                fi

              if [[ -n "$download_url" && "$download_url" != "null" ]]; then
                local matched_asset
                 matched_asset=$(echo "$latest_release" | \
                   jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
                echo "✅ 找到匹配的资产: $matched_asset"
                echo "📥 下载链接: $download_url"

                # 获取当前版本进行比较
                current_version=$(grep -E '^\s*version\s+"' "$cask_file" | sed -E 's/.*version\s+"([^"]+)".*/\1/')

                if [[ "$current_version" == "$latest_version" ]]; then
                  echo "ℹ️  $cask_file 已是最新版本 (版本 $current_version)"
                else
                  echo "📥 正在下载并计算 SHA256: $download_url..."

                  # 使用更健壮的下载和 SHA256 计算方法
                  sha256=$(curl -sL --fail "$download_url" | \
                    shasum -a 256 | awk '{print $1}')

                  if [[ -n "$sha256" && ${#sha256} -eq 64 ]]; then
                    echo "🔒 计算的 SHA256: $sha256"

                    # 检查是否为多架构 cask（包含 arch 变量）
                    if grep -q 'arch arm:' "$cask_file"; then
                      echo "🏗️  检测到多架构 cask，正在适当更新..."

                      # 对于多架构 cask，需要更新对应架构的 SHA256
                      if [[ "$download_url" == *"aarch64"* || "$download_url" == *"arm64"* ]]; then
                        # 更新 ARM 架构的 SHA256
                        sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                        sed -i "s/sha256 arm:\s*\"[^\"]*\"/sha256 arm:   \"$sha256\"/" "$cask_file"
                        echo "✅ 已更新 $cask_file 的 ARM SHA256 到版本 $latest_version"
                      elif [[ "$download_url" == *"x64"* || "$download_url" == *"x86_64"* ]]; then
                        # 更新 Intel 架构的 SHA256
                        sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                        sed -i \
                          "s/sha256.*intel:\s*\"[^\"]*\"/sha256 arm:   \"$sha256\",\n         intel: \"$sha256\"/" \
                          "$cask_file"
                        echo "✅ 已更新 $cask_file 的 Intel SHA256 到版本 $latest_version"
                      fi
                    else
                      # 单架构 cask 的标准更新
                      sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                      sed -i "s/sha256 \".*\"/sha256 \"$sha256\"/" "$cask_file"
                      echo "✅ 已更新 $cask_file 到版本 $latest_version"
                    fi

                    echo "📝 对 $cask_file 的更改:"
                    echo "   版本: $current_version → $latest_version"
                    echo "   资产: $matched_asset"
                  else
                    echo "❌ 计算 $cask_file 的有效 SHA256 失败 (得到: $sha256)"
                  fi
                fi
              else
                echo "❌ 未找到 $cask_file 的匹配资产"
                echo "   使用的模式: $asset_pattern"
                echo "   仓库: $repo_url"
                echo "   基础名称: $base_name"
                echo "   可用资产:"
                echo "$latest_release" | jq -r '.assets[].name' | sed 's/^/     - /'

                # 使用智能匹配函数进行回退匹配
                local base_name_fallback
                base_name_fallback=$(basename "$cask_file" .rb)
                local file_ext_fallback="(dmg|zip|pkg)"
                fallback_url=$(find_matching_asset "$latest_release" "$base_name_fallback" "$file_ext_fallback")
                
                if [[ -n "$fallback_url" && "$fallback_url" != "null" ]]; then
                  download_url="$fallback_url"
                  matched_asset=$(echo "$latest_release" | \
                    jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
                  echo "✅ 找到智能匹配: $matched_asset"
                  echo "📥 智能匹配下载链接: $download_url"

                  # 重新执行下载和更新逻辑
                  current_version=$(grep -E '^\s*version\s+"' "$cask_file" | \
                    sed -E 's/.*version\s+"([^"]+)".*/\1/')

                  if [[ "$current_version" != "$latest_version" ]]; then
                    echo "📥 正在下载并计算智能匹配链接的 SHA256..."
                    sha256=$(curl -sL --fail "$download_url" | \
                      shasum -a 256 | awk '{print $1}')

                    if [[ -n "$sha256" && ${#sha256} -eq 64 ]]; then
                      echo "🔒 计算的 SHA256: $sha256"
                      sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                      sed -i "s/sha256 \".*\"/sha256 \"$sha256\"/" "$cask_file"
                      echo "✅ 使用智能匹配已更新 $cask_file 到版本 $latest_version"
                      echo "📝 对 $cask_file 的更改:"
                      echo "   版本: $current_version → $latest_version"
                      echo "   资产: $matched_asset"
                    else
                      echo "❌ 计算智能匹配链接的有效 SHA256 失败 (得到: $sha256)"
                    fi
                  fi
                else
                  echo "❌ 智能匹配也未找到合适的资产"
                fi
              fi
            else
              echo "🌐 检测到非 GitHub 仓库，尝试使用替代更新方法"
              update_non_github_cask "$cask_file"
            fi
            echo "---"
          }

          # 🔍 发现并处理所有 cask 文件
          echo "🔍 在 Casks/ 目录中发现 cask 文件..."

          # 创建临时目录用于并行处理
          temp_dir=$(mktemp -d)
          trap "rm -rf $temp_dir" EXIT

          # 收集所有需要处理的cask文件
          cask_files=()
          for cask_file in Casks/*.rb; do
            if [[ -f "$cask_file" ]]; then
              cask_files+=("$cask_file")
            fi
          done

          echo "📦 发现 ${#cask_files[@]} 个 cask 文件"

          # 批量处理函数
          process_cask_batch() {
            local batch_files=("$@")
            local batch_size=${#batch_files[@]}

            echo "🔄 开始处理批次，包含 $batch_size 个文件"

            for cask_file in "${batch_files[@]}"; do
              echo "📦 处理 cask 文件: $cask_file"

              # 提取仓库信息和资源模式
              repo_info=$(extract_repo_info "$cask_file")
              repo_url=$(echo "$repo_info" | cut -d'|' -f1)
              asset_pattern=$(echo "$repo_info" | cut -d'|' -f2)

              echo "🔗 仓库: $repo_url"
              echo "🎯 资产模式: $asset_pattern"

              # 调试：检查提取的信息
              if [[ -z "$repo_url" || -z "$asset_pattern" ]]; then
                echo "⚠️  警告: 仓库 URL 或资产模式为空" >&2
                echo "   repo_info: '$repo_info'" >&2
                echo "   repo_url: '$repo_url'" >&2
                echo "   asset_pattern: '$asset_pattern'" >&2
              fi

              # 检查资产模式是否被截断或有问题
              if [[ ${#asset_pattern} -lt 10 || "$asset_pattern" == *"(aarch64" ]]; then
                echo "⚠️  警告: 资产模式被截断或不完整 (${#asset_pattern} 字符): '$asset_pattern'" >&2
                echo "🔍 重新提取完整的资产模式..." >&2

                # 重新提取完整的 URL 模板
                url_line=$(grep -E '^\s*url\s+' "$cask_file" | head -1)
                echo "完整 URL 行: $url_line" >&2

                if [[ "$url_line" =~ url[[:space:]]+\"([^\"]+)\" ]]; then
                  url_template="${BASH_REMATCH[1]}"
                  filename=$(echo "$url_template" | sed -E 's/.*\///')
                  echo "提取的文件名: $filename" >&2

                  # 重新生成完整的资产模式
                  if [[ "$filename" == *"#{version}"* && "$filename" == *"#{arch}"* ]]; then
                    # 处理包含版本和架构变量的情况
                    asset_pattern="$filename"
                    asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{version\}/[0-9]+\.[0-9]+\.[0-9]+/g')
                    asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{arch\}/(aarch64|arm64|x64|x86_64)/g')
                    asset_pattern=$(echo "$asset_pattern" | sed -E 's/\./\\./g')
                    echo "重新生成的完整模式: $asset_pattern" >&2
                  fi
                fi
              fi

              # 更新 cask
              update_cask "$cask_file" "$repo_url" "$asset_pattern"

              # 在处理间隔中添加短暂延迟，避免API过载
              sleep 1
            done
          }

          # 分批处理，每批3个文件，避免API速率限制
          batch_size=3
          total_files=${#cask_files[@]}

          for ((i=0; i<total_files; i+=batch_size)); do
            batch=("${cask_files[@]:i:batch_size}")
            batch_num=$((i/batch_size + 1))
            total_batches=$(((total_files + batch_size - 1) / batch_size))

            echo "📊 处理批次 $batch_num/$total_batches (文件 $((i+1))-$((i+${#batch[@]}))/$total_files)"

            process_cask_batch "${batch[@]}"

            # 批次间等待，确保API速率限制不被触发
            if [[ $i -lt $((total_files - batch_size)) ]]; then
              echo "⏳ 批次间等待 10 秒，避免API速率限制..."
              sleep 10
            fi
          done

          echo "🎉 所有 cask 文件已处理完成!"

      - name: Commit and push changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add Casks/

          # 检查是否有更改需要提交
          if ! git diff --quiet || ! git diff --staged --quiet; then
            # 获取已更改的 cask 文件列表
            changed_casks=$(git diff --cached --name-only | grep 'Casks/.*\.rb$' | \
              sed 's|Casks/||' | sed 's|\.rb$||' | tr '\n' ' ' | sed 's/ $//')

            if [[ -n "$changed_casks" ]]; then
              # 为每个更改的 cask 获取新版本信息
              commit_details=""
              for cask in $changed_casks; do
                cask_file="Casks/${cask}.rb"
                if [[ -f "$cask_file" ]]; then
                  new_version=$(grep -E '^\s*version\s+' "$cask_file" | head -1 | \
                    sed -E 's/.*version\s+"([^"]+)".*/\1/')
                  if [[ -n "$new_version" ]]; then
                    commit_details="${commit_details}\n- ${cask}: 更新到 v${new_version}"
                  else
                    commit_details="${commit_details}\n- ${cask}: 已更新"
                  fi
                fi
              done

              # 构建详细的提交信息
              commit_message="🚀 更新 Homebrew Casks

              本次更新包含以下应用:$(echo -e "${commit_details}")

              📅 更新时间: $(date '+%Y-%m-%d %H:%M:%S')
              🤖 自动更新 by GitHub Actions"

              git commit -m "$commit_message"
              echo "✅ 已提交更改，包含以下应用更新: $changed_casks"
            else
              git commit -m "🔧 更新 Homebrew Casks 配置文件"
              echo "✅ 已提交配置文件更改"
            fi

            # 只在有提交时才推送
            echo "📤 正在推送更改到远程仓库..."
            git pull --rebase origin main || {
              echo "⚠️  拉取远程更改失败，尝试强制推送..."
              git push --force-with-lease
            } && git push
            echo "✅ 更改已成功推送到远程仓库"
          else
            echo "ℹ️  没有检测到需要提交的更改，跳过推送操作"
          fi
