---
name: Update Casks

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch: {}

concurrency:
  group: update-casks
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 90
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gem
            vendor/bundle
          key: ${{ runner.os }}-ruby-3.2-${{ hashFiles('**/Gemfile.lock', '**/gems.locked') }}
          restore-keys: |
            ${{ runner.os }}-ruby-3.2-
            ${{ runner.os }}-ruby-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Update all casks
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          
          # å…¨å±€é…ç½®
          readonly API_BASE_URL="https://api.github.com"
          readonly MIN_RATE_LIMIT=15
          readonly BATCH_SIZE=3
          readonly BATCH_DELAY=10
          readonly REQUEST_DELAY=2
          readonly MAX_RETRIES=3
          readonly BACKOFF_BASE=2
          
          # é¢œè‰²è¾“å‡º
          readonly RED='\033[0;31m'
          readonly GREEN='\033[0;32m'
          readonly YELLOW='\033[1;33m'
          readonly BLUE='\033[0;34m'
          readonly NC='\033[0m' # No Color
          
          # æ—¥å¿—å‡½æ•°
          log() {
            local level=$1
            shift
            local message="$*"
            local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            
            case $level in
              "INFO")  echo -e "${BLUE}[INFO]${NC} ${timestamp} - $message" ;;
              "WARN")  echo -e "${YELLOW}[WARN]${NC} ${timestamp} - $message" ;;
              "ERROR") echo -e "${RED}[ERROR]${NC} ${timestamp} - $message" ;;
              "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} ${timestamp} - $message" ;;
              *) echo "[$level] ${timestamp} - $message" ;;
            esac
          }
          
          # API é€Ÿç‡é™åˆ¶æ£€æŸ¥
          check_rate_limit() {
            local min_remaining=${1:-$MIN_RATE_LIMIT}
            local rate_check
            
            rate_check=$(curl -sf -H "Authorization: token $GITHUB_TOKEN" \
              "$API_BASE_URL/rate_limit" 2>/dev/null || echo '{"rate":{"remaining":0,"reset":0}}')
            
            local remaining=$(echo "$rate_check" | jq -r '.rate.remaining // 0')
            local reset=$(echo "$rate_check" | jq -r '.rate.reset // 0')
            
            log "INFO" "APIå‰©ä½™è¯·æ±‚æ•°: $remaining"
            
            if [[ $remaining -lt $min_remaining ]]; then
              local current_time=$(date +%s)
              local wait_time=$((reset - current_time + 60))
              
              if [[ $wait_time -gt 0 && $wait_time -lt 3600 ]]; then
                log "WARN" "APIé€Ÿç‡é™åˆ¶ä¸è¶³ï¼Œç­‰å¾… $wait_time ç§’..."
                sleep $wait_time
                return 0
              else
                log "ERROR" "APIé€Ÿç‡é™åˆ¶è€—å°½ä¸”é‡ç½®æ—¶é—´å¼‚å¸¸"
                return 1
              fi
            fi
            
            sleep $REQUEST_DELAY
            return 0
          }
          
          # æ™ºèƒ½APIè¯·æ±‚
          make_api_request() {
            local url="$1"
            local retry_count=0
            local response
            
            while [[ $retry_count -lt $MAX_RETRIES ]]; do
              if ! check_rate_limit; then
                log "ERROR" "APIé€Ÿç‡é™åˆ¶æ£€æŸ¥å¤±è´¥"
                return 1
              fi
              
              log "INFO" "APIè¯·æ±‚ (å°è¯• $((retry_count + 1))/$MAX_RETRIES): $url"
              response=$(curl -sf -H "Authorization: token $GITHUB_TOKEN" "$url" 2>/dev/null)
              
              if [[ -n "$response" && "$response" != "null" ]]; then
                echo "$response"
                return 0
              fi
              
              retry_count=$((retry_count + 1))
              if [[ $retry_count -lt $MAX_RETRIES ]]; then
                local wait_time=$((BACKOFF_BASE ** retry_count))
                log "WARN" "è¯·æ±‚å¤±è´¥ï¼Œç­‰å¾… $wait_time ç§’åé‡è¯•..."
                sleep $wait_time
              fi
            done
            
            log "ERROR" "APIè¯·æ±‚æœ€ç»ˆå¤±è´¥: $url"
            return 1
          }
          
          # ä» cask æ–‡ä»¶æå–ä»“åº“ä¿¡æ¯
          extract_repo_info() {
            local cask_file="$1"
            local repo_url=""
            local asset_pattern=""
            
            # æå– homepage æˆ–ä» URL æ¨æ–­ GitHub ä»“åº“
            repo_url=$(grep -E '^\s*homepage\s+"' "$cask_file" | sed -E 's/.*"([^"]+)".*/\1/' || true)
            
            if [[ "$repo_url" != *"github.com"* ]]; then
              repo_url=$(grep -E '^\s*url\s+"' "$cask_file" | head -1 | \
                sed -E 's/.*"https:\/\/github\.com\/([^\/]+\/[^\/]+)\/.*/https:\/\/github.com\/\1/' || true)
            fi
            
            # æå–èµ„äº§æ¨¡å¼
            local url_line
            url_line=$(grep -E '^\s*url\s+"' "$cask_file" | head -1 || true)
            
            if [[ "$url_line" =~ url[[:space:]]+\"([^\"]+)\" ]]; then
              local url_template="${BASH_REMATCH[1]}"
              local filename=$(basename "$url_template")
              
              # å¤„ç†æ¨¡æ¿å˜é‡
              asset_pattern="$filename"
              asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{version\}/[0-9]+\.[0-9]+(\.[0-9]+)?/g')
              asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{arch\}/(aarch64|arm64|x64|x86_64)/g')
              asset_pattern=$(echo "$asset_pattern" | sed -E 's/\./\\./g')
            fi
            
            printf "%s|%s\n" "$repo_url" "$asset_pattern"
          }
          
          # æ™ºèƒ½èµ„äº§åŒ¹é…
          find_matching_asset() {
            local latest_release="$1"
            local base_name="$2"
            local file_ext="$3"
            
            # ä¼˜å…ˆçº§åŒ¹é…ç­–ç•¥
            local strategies=(
              "exact:$base_name\\.$file_ext"
              "dash_to_dot:$(echo "$base_name" | sed 's/-/\\./g')\\.$file_ext"
              "contains:$base_name.*\\.$file_ext"
              "app_name:$(echo "$base_name" | sed -E 's/-([a-z])/\\U\\1/g').*\\.$file_ext"
            )
            
            for strategy in "${strategies[@]}"; do
              local strategy_type="${strategy%%:*}"
              local pattern="${strategy#*:}"
              
              log "INFO" "å°è¯•åŒ¹é…ç­–ç•¥: $strategy_type -> $pattern"
              
              # ä¼˜å…ˆåŒ¹é… Apple Silicon æ¶æ„
              local download_url
              download_url=$(echo "$latest_release" | \
                jq -r --arg pattern "$pattern" \
                '.assets[] | select(.name | test($pattern; "i")) | 
                 select(.name | test("(aarch64|arm64)"; "i")) | 
                 .browser_download_url' | head -1)
              
              # å¦‚æœæ²¡æœ‰ ARM ç‰ˆæœ¬ï¼Œå°è¯•é€šç”¨ç‰ˆæœ¬
              if [[ -z "$download_url" || "$download_url" == "null" ]]; then
                download_url=$(echo "$latest_release" | \
                  jq -r --arg pattern "$pattern" \
                  '.assets[] | select(.name | test($pattern; "i")) | 
                   .browser_download_url' | head -1)
              fi
              
              if [[ -n "$download_url" && "$download_url" != "null" ]]; then
                local matched_file
                matched_file=$(echo "$latest_release" | \
                  jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
                log "SUCCESS" "åŒ¹é…æˆåŠŸ: $matched_file"
                echo "$download_url"
                return 0
              fi
            done
            
            log "ERROR" "æ‰€æœ‰åŒ¹é…ç­–ç•¥å‡å¤±è´¥"
            return 1
          }
          
          # æ›´æ–°å•ä¸ª cask
          update_cask() {
            local cask_file="$1"
            local repo_url="$2"
            local asset_pattern="$3"
            
            log "INFO" "å¤„ç† $cask_file"
            
            if [[ "$repo_url" != *"github.com"* ]]; then
              log "WARN" "è·³è¿‡ $cask_file (é GitHub ä»“åº“)"
              return 0
            fi
            
            local owner_repo
            owner_repo=$(echo "$repo_url" | sed -E 's|https://github.com/([^/]+/[^/]+).*|\1|')
            
            log "INFO" "è·å– $owner_repo çš„æœ€æ–°ç‰ˆæœ¬"
            
            local latest_release
            latest_release=$(make_api_request "$API_BASE_URL/repos/$owner_repo/releases/latest")
            
            if [[ -z "$latest_release" ]]; then
              log "ERROR" "è·å–æœ€æ–°ç‰ˆæœ¬å¤±è´¥: $owner_repo"
              return 1
            fi
            
            local latest_version
            latest_version=$(echo "$latest_release" | jq -r '.tag_name' | sed 's/^v//')
            
            if [[ "$latest_version" == "null" || -z "$latest_version" ]]; then
              log "ERROR" "è§£æç‰ˆæœ¬å¤±è´¥: $owner_repo"
              return 1
            fi
            
            log "INFO" "æœ€æ–°ç‰ˆæœ¬: $latest_version"
            
            local current_version
            current_version=$(grep -E '^\s*version\s+"' "$cask_file" | \
              sed -E 's/.*version\s+"([^"]+)".*/\1/' || true)
            
            if [[ "$current_version" == "$latest_version" ]]; then
              log "INFO" "$cask_file å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ ($current_version)"
              return 0
            fi
            
            # æŸ¥æ‰¾åŒ¹é…çš„èµ„äº§
            local download_url
            if [[ -n "$asset_pattern" ]]; then
              download_url=$(echo "$latest_release" | \
                jq -r --arg pattern "$asset_pattern" \
                '.assets[] | select(.name | test($pattern; "i")) | .browser_download_url' | head -1)
            fi
            
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œä½¿ç”¨æ™ºèƒ½åŒ¹é…
            if [[ -z "$download_url" || "$download_url" == "null" ]]; then
              local base_name
              base_name=$(basename "$cask_file" .rb)
              local file_ext="(dmg|zip|pkg)"
              
              download_url=$(find_matching_asset "$latest_release" "$base_name" "$file_ext")
            fi
            
            if [[ -z "$download_url" || "$download_url" == "null" ]]; then
              log "ERROR" "æœªæ‰¾åˆ°åŒ¹é…çš„èµ„äº§: $cask_file"
              return 1
            fi
            
            local matched_asset
            matched_asset=$(echo "$latest_release" | \
              jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
            
            log "INFO" "ä¸‹è½½å¹¶è®¡ç®— SHA256: $matched_asset"
            
            local sha256
            sha256=$(curl -sL --fail "$download_url" | shasum -a 256 | awk '{print $1}')
            
            if [[ -z "$sha256" || ${#sha256} -ne 64 ]]; then
              log "ERROR" "è®¡ç®— SHA256 å¤±è´¥: $cask_file"
              return 1
            fi
            
            log "INFO" "SHA256: $sha256"
            
            # æ›´æ–°æ–‡ä»¶
            if grep -q 'arch arm:' "$cask_file"; then
              # å¤šæ¶æ„å¤„ç†
              if [[ "$download_url" == *"aarch64"* || "$download_url" == *"arm64"* ]]; then
                sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                sed -i "s/sha256 arm:\s*\"[^\"]*\"/sha256 arm:   \"$sha256\"/" "$cask_file"
              else
                sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                sed -i "s/sha256.*intel:\s*\"[^\"]*\"/sha256 intel: \"$sha256\"/" "$cask_file"
              fi
            else
              # å•æ¶æ„å¤„ç†
              sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
              sed -i "s/sha256 \".*\"/sha256 \"$sha256\"/" "$cask_file"
            fi
            
            log "SUCCESS" "æ›´æ–°å®Œæˆ: $cask_file ($current_version â†’ $latest_version)"
            echo "$cask_file:$current_version:$latest_version:$matched_asset" >> /tmp/updated_casks.txt
            
            return 0
          }
          
          # ä¸»å¤„ç†é€»è¾‘
          main() {
            log "INFO" "å¼€å§‹æ›´æ–° Homebrew Casks"
            
            # æ”¶é›†æ‰€æœ‰ cask æ–‡ä»¶
            local cask_files=()
            while IFS= read -r -d '' file; do
              cask_files+=("$file")
            done < <(find Casks -name "*.rb" -type f -print0)
            
            local total_files=${#cask_files[@]}
            log "INFO" "å‘ç° $total_files ä¸ª cask æ–‡ä»¶"
            
            # åˆå§‹åŒ–æ›´æ–°è®°å½•
            > /tmp/updated_casks.txt
            
            # åˆ†æ‰¹å¤„ç†
            local batch_num=1
            local total_batches=$(((total_files + BATCH_SIZE - 1) / BATCH_SIZE))
            
            for ((i=0; i<total_files; i+=BATCH_SIZE)); do
              local batch=("${cask_files[@]:i:BATCH_SIZE}")
              
              log "INFO" "å¤„ç†æ‰¹æ¬¡ $batch_num/$total_batches"
              
              for cask_file in "${batch[@]}"; do
                local repo_info
                repo_info=$(extract_repo_info "$cask_file")
                local repo_url="${repo_info%%|*}"
                local asset_pattern="${repo_info#*|}"
                
                update_cask "$cask_file" "$repo_url" "$asset_pattern" || true
              done
              
              batch_num=$((batch_num + 1))
              
              if [[ $i -lt $((total_files - BATCH_SIZE)) ]]; then
                log "INFO" "æ‰¹æ¬¡é—´ç­‰å¾… $BATCH_DELAY ç§’..."
                sleep $BATCH_DELAY
              fi
            done
            
            log "SUCCESS" "æ‰€æœ‰ cask æ–‡ä»¶å¤„ç†å®Œæˆ"
          }
          
          # è¿è¡Œä¸»ç¨‹åº
          main

      - name: Commit and push changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add Casks/

          if git diff --quiet --staged; then
            echo "â„¹ï¸ æ²¡æœ‰éœ€è¦æäº¤çš„æ›´æ”¹"
            exit 0
          fi

          # æ„å»ºæäº¤ä¿¡æ¯
          updated_count=0
          commit_details=""
          
          if [[ -f /tmp/updated_casks.txt ]]; then
            while IFS=: read -r cask_file old_version new_version asset_name; do
              cask_name=$(basename "$cask_file" .rb)
              commit_details="${commit_details}\n- ${cask_name}: ${old_version} â†’ ${new_version}"
              updated_count=$((updated_count + 1))
            done < /tmp/updated_casks.txt
          fi

          if [[ $updated_count -eq 0 ]]; then
            commit_message="ğŸ”§ æ›´æ–° Homebrew Casks é…ç½®"
          else
            commit_message="ğŸš€ æ›´æ–° ${updated_count} ä¸ª Homebrew Casks

          æœ¬æ¬¡æ›´æ–°:${commit_details}

          ğŸ“… æ›´æ–°æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S UTC')
          ğŸ¤– è‡ªåŠ¨æ›´æ–° by GitHub Actions"
          fi

          git commit -m "$commit_message"
          
          # æ¨é€æ›´æ”¹
          if git pull --rebase origin main; then
            git push
          else
            echo "âš ï¸ æ‹‰å–å¤±è´¥ï¼Œå°è¯•å¼ºåˆ¶æ¨é€..."
            git push --force-with-lease
          fi
          
          echo "âœ… æ›´æ”¹å·²æ¨é€åˆ°è¿œç¨‹ä»“åº“"
