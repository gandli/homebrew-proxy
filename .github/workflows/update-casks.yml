---
name: Update Casks

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch: {}

concurrency:
  group: update-casks
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 90
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gem
            vendor/bundle
          key: ${{ runner.os }}-ruby-3.2-${{ hashFiles('**/Gemfile.lock', '**/gems.locked') }}
          restore-keys: |
            ${{ runner.os }}-ruby-3.2-
            ${{ runner.os }}-ruby-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Update all casks
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          
          # 全局配置
          readonly API_BASE_URL="https://api.github.com"
          readonly MIN_RATE_LIMIT=15
          readonly BATCH_SIZE=3
          readonly BATCH_DELAY=10
          readonly REQUEST_DELAY=2
          readonly MAX_RETRIES=3
          readonly BACKOFF_BASE=2
          
          # 颜色输出
          readonly RED='\033[0;31m'
          readonly GREEN='\033[0;32m'
          readonly YELLOW='\033[1;33m'
          readonly BLUE='\033[0;34m'
          readonly NC='\033[0m' # No Color
          
          # 日志函数
          log() {
            local level=$1
            shift
            local message="$*"
            local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            
            case $level in
              "INFO")  echo -e "${BLUE}[INFO]${NC} ${timestamp} - $message" ;;
              "WARN")  echo -e "${YELLOW}[WARN]${NC} ${timestamp} - $message" ;;
              "ERROR") echo -e "${RED}[ERROR]${NC} ${timestamp} - $message" ;;
              "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} ${timestamp} - $message" ;;
              *) echo "[$level] ${timestamp} - $message" ;;
            esac
          }
          
          # API 速率限制检查
          check_rate_limit() {
            local min_remaining=${1:-$MIN_RATE_LIMIT}
            local rate_check
            
            rate_check=$(curl -sf -H "Authorization: token $GITHUB_TOKEN" \
              "$API_BASE_URL/rate_limit" 2>/dev/null || echo '{"rate":{"remaining":0,"reset":0}}')
            
            local remaining=$(echo "$rate_check" | jq -r '.rate.remaining // 0')
            local reset=$(echo "$rate_check" | jq -r '.rate.reset // 0')
            
            log "INFO" "API剩余请求数: $remaining"
            
            if [[ $remaining -lt $min_remaining ]]; then
              local current_time=$(date +%s)
              local wait_time=$((reset - current_time + 60))
              
              if [[ $wait_time -gt 0 && $wait_time -lt 3600 ]]; then
                log "WARN" "API速率限制不足，等待 $wait_time 秒..."
                sleep $wait_time
                return 0
              else
                log "ERROR" "API速率限制耗尽且重置时间异常"
                return 1
              fi
            fi
            
            sleep $REQUEST_DELAY
            return 0
          }
          
          # 智能API请求
          make_api_request() {
            local url="$1"
            local retry_count=0
            local response
            
            while [[ $retry_count -lt $MAX_RETRIES ]]; do
              if ! check_rate_limit; then
                log "ERROR" "API速率限制检查失败"
                return 1
              fi
              
              log "INFO" "API请求 (尝试 $((retry_count + 1))/$MAX_RETRIES): $url"
              response=$(curl -sf -H "Authorization: token $GITHUB_TOKEN" "$url" 2>/dev/null)
              
              if [[ -n "$response" && "$response" != "null" ]]; then
                echo "$response"
                return 0
              fi
              
              retry_count=$((retry_count + 1))
              if [[ $retry_count -lt $MAX_RETRIES ]]; then
                local wait_time=$((BACKOFF_BASE ** retry_count))
                log "WARN" "请求失败，等待 $wait_time 秒后重试..."
                sleep $wait_time
              fi
            done
            
            log "ERROR" "API请求最终失败: $url"
            return 1
          }
          
          # 从 cask 文件提取仓库信息
          extract_repo_info() {
            local cask_file="$1"
            local repo_url=""
            local asset_pattern=""
            
            # 提取 homepage 或从 URL 推断 GitHub 仓库
            repo_url=$(grep -E '^\s*homepage\s+"' "$cask_file" | sed -E 's/.*"([^"]+)".*/\1/' || true)
            
            if [[ "$repo_url" != *"github.com"* ]]; then
              repo_url=$(grep -E '^\s*url\s+"' "$cask_file" | head -1 | \
                sed -E 's/.*"https:\/\/github\.com\/([^\/]+\/[^\/]+)\/.*/https:\/\/github.com\/\1/' || true)
            fi
            
            # 提取资产模式
            local url_line
            url_line=$(grep -E '^\s*url\s+"' "$cask_file" | head -1 || true)
            
            if [[ "$url_line" =~ url[[:space:]]+\"([^\"]+)\" ]]; then
              local url_template="${BASH_REMATCH[1]}"
              local filename=$(basename "$url_template")
              
              # 处理模板变量
              asset_pattern="$filename"
              asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{version\}/[0-9]+\.[0-9]+(\.[0-9]+)?/g')
              asset_pattern=$(echo "$asset_pattern" | sed -E 's/#\{arch\}/(aarch64|arm64|x64|x86_64)/g')
              asset_pattern=$(echo "$asset_pattern" | sed -E 's/\./\\./g')
            fi
            
            printf "%s|%s\n" "$repo_url" "$asset_pattern"
          }
          
          # 智能资产匹配
          find_matching_asset() {
            local latest_release="$1"
            local base_name="$2"
            local file_ext="$3"
            
            # 优先级匹配策略
            local strategies=(
              "exact:$base_name\\.$file_ext"
              "dash_to_dot:$(echo "$base_name" | sed 's/-/\\./g')\\.$file_ext"
              "contains:$base_name.*\\.$file_ext"
              "app_name:$(echo "$base_name" | sed -E 's/-([a-z])/\\U\\1/g').*\\.$file_ext"
            )
            
            for strategy in "${strategies[@]}"; do
              local strategy_type="${strategy%%:*}"
              local pattern="${strategy#*:}"
              
              log "INFO" "尝试匹配策略: $strategy_type -> $pattern"
              
              # 优先匹配 Apple Silicon 架构
              local download_url
              download_url=$(echo "$latest_release" | \
                jq -r --arg pattern "$pattern" \
                '.assets[] | select(.name | test($pattern; "i")) | 
                 select(.name | test("(aarch64|arm64)"; "i")) | 
                 .browser_download_url' | head -1)
              
              # 如果没有 ARM 版本，尝试通用版本
              if [[ -z "$download_url" || "$download_url" == "null" ]]; then
                download_url=$(echo "$latest_release" | \
                  jq -r --arg pattern "$pattern" \
                  '.assets[] | select(.name | test($pattern; "i")) | 
                   .browser_download_url' | head -1)
              fi
              
              if [[ -n "$download_url" && "$download_url" != "null" ]]; then
                local matched_file
                matched_file=$(echo "$latest_release" | \
                  jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
                log "SUCCESS" "匹配成功: $matched_file"
                echo "$download_url"
                return 0
              fi
            done
            
            log "ERROR" "所有匹配策略均失败"
            return 1
          }
          
          # 更新单个 cask
          update_cask() {
            local cask_file="$1"
            local repo_url="$2"
            local asset_pattern="$3"
            
            log "INFO" "处理 $cask_file"
            
            if [[ "$repo_url" != *"github.com"* ]]; then
              log "WARN" "跳过 $cask_file (非 GitHub 仓库)"
              return 0
            fi
            
            local owner_repo
            owner_repo=$(echo "$repo_url" | sed -E 's|https://github.com/([^/]+/[^/]+).*|\1|')
            
            log "INFO" "获取 $owner_repo 的最新版本"
            
            local latest_release
            latest_release=$(make_api_request "$API_BASE_URL/repos/$owner_repo/releases/latest")
            
            if [[ -z "$latest_release" ]]; then
              log "ERROR" "获取最新版本失败: $owner_repo"
              return 1
            fi
            
            local latest_version
            latest_version=$(echo "$latest_release" | jq -r '.tag_name' | sed 's/^v//')
            
            if [[ "$latest_version" == "null" || -z "$latest_version" ]]; then
              log "ERROR" "解析版本失败: $owner_repo"
              return 1
            fi
            
            log "INFO" "最新版本: $latest_version"
            
            local current_version
            current_version=$(grep -E '^\s*version\s+"' "$cask_file" | \
              sed -E 's/.*version\s+"([^"]+)".*/\1/' || true)
            
            if [[ "$current_version" == "$latest_version" ]]; then
              log "INFO" "$cask_file 已是最新版本 ($current_version)"
              return 0
            fi
            
            # 查找匹配的资产
            local download_url
            if [[ -n "$asset_pattern" ]]; then
              download_url=$(echo "$latest_release" | \
                jq -r --arg pattern "$asset_pattern" \
                '.assets[] | select(.name | test($pattern; "i")) | .browser_download_url' | head -1)
            fi
            
            # 如果没有找到，使用智能匹配
            if [[ -z "$download_url" || "$download_url" == "null" ]]; then
              local base_name
              base_name=$(basename "$cask_file" .rb)
              local file_ext="(dmg|zip|pkg)"
              
              download_url=$(find_matching_asset "$latest_release" "$base_name" "$file_ext")
            fi
            
            if [[ -z "$download_url" || "$download_url" == "null" ]]; then
              log "ERROR" "未找到匹配的资产: $cask_file"
              return 1
            fi
            
            local matched_asset
            matched_asset=$(echo "$latest_release" | \
              jq -r ".assets[] | select(.browser_download_url == \"$download_url\") | .name")
            
            log "INFO" "下载并计算 SHA256: $matched_asset"
            
            local sha256
            sha256=$(curl -sL --fail "$download_url" | shasum -a 256 | awk '{print $1}')
            
            if [[ -z "$sha256" || ${#sha256} -ne 64 ]]; then
              log "ERROR" "计算 SHA256 失败: $cask_file"
              return 1
            fi
            
            log "INFO" "SHA256: $sha256"
            
            # 更新文件
            if grep -q 'arch arm:' "$cask_file"; then
              # 多架构处理
              if [[ "$download_url" == *"aarch64"* || "$download_url" == *"arm64"* ]]; then
                sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                sed -i "s/sha256 arm:\s*\"[^\"]*\"/sha256 arm:   \"$sha256\"/" "$cask_file"
              else
                sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
                sed -i "s/sha256.*intel:\s*\"[^\"]*\"/sha256 intel: \"$sha256\"/" "$cask_file"
              fi
            else
              # 单架构处理
              sed -i "s/version \".*\"/version \"$latest_version\"/" "$cask_file"
              sed -i "s/sha256 \".*\"/sha256 \"$sha256\"/" "$cask_file"
            fi
            
            log "SUCCESS" "更新完成: $cask_file ($current_version → $latest_version)"
            echo "$cask_file:$current_version:$latest_version:$matched_asset" >> /tmp/updated_casks.txt
            
            return 0
          }
          
          # 主处理逻辑
          main() {
            log "INFO" "开始更新 Homebrew Casks"
            
            # 收集所有 cask 文件
            local cask_files=()
            while IFS= read -r -d '' file; do
              cask_files+=("$file")
            done < <(find Casks -name "*.rb" -type f -print0)
            
            local total_files=${#cask_files[@]}
            log "INFO" "发现 $total_files 个 cask 文件"
            
            # 初始化更新记录
            > /tmp/updated_casks.txt
            
            # 分批处理
            local batch_num=1
            local total_batches=$(((total_files + BATCH_SIZE - 1) / BATCH_SIZE))
            
            for ((i=0; i<total_files; i+=BATCH_SIZE)); do
              local batch=("${cask_files[@]:i:BATCH_SIZE}")
              
              log "INFO" "处理批次 $batch_num/$total_batches"
              
              for cask_file in "${batch[@]}"; do
                local repo_info
                repo_info=$(extract_repo_info "$cask_file")
                local repo_url="${repo_info%%|*}"
                local asset_pattern="${repo_info#*|}"
                
                update_cask "$cask_file" "$repo_url" "$asset_pattern" || true
              done
              
              batch_num=$((batch_num + 1))
              
              if [[ $i -lt $((total_files - BATCH_SIZE)) ]]; then
                log "INFO" "批次间等待 $BATCH_DELAY 秒..."
                sleep $BATCH_DELAY
              fi
            done
            
            log "SUCCESS" "所有 cask 文件处理完成"
          }
          
          # 运行主程序
          main

      - name: Commit and push changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add Casks/

          if git diff --quiet --staged; then
            echo "ℹ️ 没有需要提交的更改"
            exit 0
          fi

          # 构建提交信息
          updated_count=0
          commit_details=""
          
          if [[ -f /tmp/updated_casks.txt ]]; then
            while IFS=: read -r cask_file old_version new_version asset_name; do
              cask_name=$(basename "$cask_file" .rb)
              commit_details="${commit_details}\n- ${cask_name}: ${old_version} → ${new_version}"
              updated_count=$((updated_count + 1))
            done < /tmp/updated_casks.txt
          fi

          if [[ $updated_count -eq 0 ]]; then
            commit_message="🔧 更新 Homebrew Casks 配置"
          else
            commit_message="🚀 更新 ${updated_count} 个 Homebrew Casks

          本次更新:${commit_details}

          📅 更新时间: $(date '+%Y-%m-%d %H:%M:%S UTC')
          🤖 自动更新 by GitHub Actions"
          fi

          git commit -m "$commit_message"
          
          # 推送更改
          if git pull --rebase origin main; then
            git push
          else
            echo "⚠️ 拉取失败，尝试强制推送..."
            git push --force-with-lease
          fi
          
          echo "✅ 更改已推送到远程仓库"
