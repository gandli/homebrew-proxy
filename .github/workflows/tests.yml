---
name: Test

'on':
  pull_request: {}
  push: {}

jobs:
  testing:
    runs-on: macos-latest
    timeout-minutes: 60
    concurrency:
      group: test-${{ github.ref }}
      cancel-in-progress: true
    env:
      HOMEBREW_NO_AUTO_UPDATE: 1
      HOMEBREW_NO_INSTALL_FROM_API: 1
      HOMEBREW_NO_ANALYTICS: 1
      HOMEBREW_NO_INSECURE_REDIRECT: 1
      LANG: zh_CN.UTF-8
      LC_ALL: zh_CN.UTF-8
    steps:
      - name: checkout repository
        uses: actions/checkout@v4
      - name: Cache Homebrew
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/Homebrew
            /opt/homebrew/var/homebrew/locks
            /opt/homebrew/Library/Taps
          key: homebrew-${{ runner.os }}-${{ hashFiles('Casks/*.rb') }}
          restore-keys: |
            homebrew-${{ runner.os }}-

      - name: test cask syntax
        run: |
          # 在 CI 环境中正确添加本地 tap
          mkdir -p "$(brew --repository)/Library/Taps/gandli"
          ln -sf "${PWD}" "$(brew --repository)/Library/Taps/gandli/homebrew-proxy"

          # 验证 tap 是否正确添加
          brew tap | grep gandli/proxy || echo "Tap 添加失败"

          # 列出可用的 casks
          echo "可用的 Casks:"
          brew search gandli/proxy/ || true

          # 检查所有 Cask 文件的语法
          echo "正在检查 Cask 语法..."
          for cask_file in Casks/*.rb; do
            if [ -f "$cask_file" ]; then
              cask_name=$(basename "$cask_file" .rb)
              echo "正在检查 ${cask_name} 的语法"
              # 检查 Cask 语法（处理被禁用的应用）
              if brew audit --cask "gandli/proxy/${cask_name}" 2>&1 | tee /tmp/audit_output.log; then
                echo "✅ ${cask_name} 语法检查通过"
              else
                # 检查是否是因为应用被禁用导致的失败
                if grep -q "disabled because it is discontinued upstream" /tmp/audit_output.log; then
                  echo "⚠️ ${cask_name} 已被上游停止维护，跳过语法检查"
                elif grep -q "has been disabled" /tmp/audit_output.log; then
                  echo "⚠️ ${cask_name} 已被禁用，跳过语法检查"
                else
                  echo "⚠️ ${cask_name} 语法检查有警告或错误"
                  cat /tmp/audit_output.log
                fi
              fi
            fi
          done
      - name: test cask installation (macOS only)
        if: runner.os == 'macOS'
        run: |
          # 动态获取所有 Cask 文件并进行安装测试
          for cask_file in Casks/*.rb; do
            if [ -f "$cask_file" ]; then
              # 从文件名提取 Cask 名称（去掉路径和 .rb 扩展名）
              cask_name=$(basename "$cask_file" .rb)
              echo "正在测试 Cask: ${cask_name}"

              # 安装 Cask（处理被禁用的应用）
              echo "正在尝试安装 ${cask_name}..."
              if brew install --cask "gandli/proxy/${cask_name}" 2>&1 | tee /tmp/install_output.log; then
                echo "✅ ${cask_name} 安装成功"
              else
                # 检查是否是因为应用被禁用导致的失败
                if grep -q "disabled because it is discontinued upstream" /tmp/install_output.log; then
                  echo "⚠️ ${cask_name} 已被上游停止维护，跳过安装测试"
                  echo "---"
                  continue
                elif grep -q "has been disabled" /tmp/install_output.log; then
                  echo "⚠️ ${cask_name} 已被禁用，跳过安装测试"
                  echo "---"
                  continue
                else
                  echo "❌ ${cask_name} 安装失败"
                  cat /tmp/install_output.log
                  echo "---"
                  continue
                fi
              fi

              # 检查应用程序的安装状态和版本信息
              echo "🔍 正在验证应用程序安装状态..."

              # 检查是否为 pkg 类型的 Cask
              if grep -q "pkg " "${cask_file}"; then
                echo "📦 检测到 PKG 类型安装"

                # 从 Cask 文件中提取 pkgutil 信息
                pkg_id=$(grep -E '^[[:space:]]*pkgutil:[[:space:]]*".*"' "${cask_file}" | \
                  sed -E 's/^[[:space:]]*pkgutil:[[:space:]]*"(.*)".*$/\1/' | head -1)

                if [ -n "${pkg_id}" ]; then
                  echo "📋 Package ID: ${pkg_id}"

                  # 检查包是否已安装
                  if pkgutil --pkg-info "${pkg_id}" >/dev/null 2>&1; then
                    echo "✅ PKG 包已成功安装"

                    # 获取包的详细信息
                    pkg_version=$(pkgutil --pkg-info "${pkg_id}" | grep "version:" | cut -d: -f2 | xargs)
                    pkg_location=$(pkgutil --pkg-info "${pkg_id}" | grep "location:" | cut -d: -f2 | xargs)
                    pkg_install_time=$(pkgutil --pkg-info "${pkg_id}" | grep "install-time:" | cut -d: -f2 | xargs)

                    echo "📱 包版本: ${pkg_version:-未知}"
                    echo "📍 安装位置: ${pkg_location:-未知}"
                    echo "⏰ 安装时间: ${pkg_install_time:-未知}"

                    # 尝试查找实际的应用程序位置
                    echo "🔍 正在搜索应用程序文件..."
                    app_locations=$(find /Applications /System/Applications /usr/local \
                      -name "*${cask_name}*" -o -name "*Mihomo*" 2>/dev/null | \
                      head -5)
                    if [ -n "${app_locations}" ]; then
                      echo "📂 找到相关文件:"
                      echo "${app_locations}"
                    else
                      echo "⚠️ 未找到明显的应用程序文件"
                    fi
                  else
                    echo "❌ PKG 包安装验证失败"
                  fi
                else
                  echo "⚠️ 无法从 Cask 文件中解析 Package ID"
                  echo "🔍 正在搜索可能的安装位置..."
                  find /Applications -name "*${cask_name}*" -type d -maxdepth 2 2>/dev/null || echo "未找到相关应用程序"
                fi
              else
                # 处理 app 类型的 Cask
                echo "📱 检测到 APP 类型安装"

                # 动态从 Cask 文件中提取应用程序名称
                app_name=$(grep -E '^[[:space:]]*app[[:space:]]+".*"' "${cask_file}" | \
                  sed -E 's/^[[:space:]]*app[[:space:]]+"(.*)".*$/\1/' | head -1)

                if [ -n "${app_name}" ]; then
                  app_path="/Applications/${app_name}"
                  echo "📍 预期安装路径: ${app_path}"

                  if [ -d "${app_path}" ]; then
                    echo "✅ 应用程序已成功安装"

                    # 尝试从 Info.plist 获取版本信息
                    info_plist="${app_path}/Contents/Info.plist"
                    if [ -f "${info_plist}" ]; then
                      app_version=$(defaults read "${info_plist}" CFBundleShortVersionString 2>/dev/null || \
                        defaults read "${info_plist}" CFBundleVersion 2>/dev/null || echo "未知")
                      echo "📱 应用版本: ${app_version}"

                      # 获取应用程序的 Bundle Identifier
                      bundle_id=$(defaults read "${info_plist}" CFBundleIdentifier 2>/dev/null || echo "未知")
                      echo "🆔 Bundle ID: ${bundle_id}"
                    else
                      echo "⚠️ 无法读取应用版本信息 (Info.plist 不存在)"
                    fi

                    # 检查应用程序大小
                    app_size=$(du -sh "${app_path}" 2>/dev/null | cut -f1 || echo "未知")
                    echo "💾 应用大小: ${app_size}"

                  else
                    echo "❌ 应用程序安装失败: 在预期路径未找到应用"
                    echo "🔍 正在搜索可能的安装位置..."
                    find /Applications -name "*${cask_name}*" -type d -maxdepth 2 2>/dev/null || echo "未找到相关应用程序"
                  fi
                else
                  echo "⚠️ 无法从 Cask 文件中解析应用程序名称"
                  echo "🔍 正在搜索可能的安装位置..."
                  find /Applications -name "*${cask_name}*" -type d -maxdepth 2 2>/dev/null || echo "未找到相关应用程序"
                fi
              fi

              echo "成功安装 ${cask_name}"
              echo "---"
            fi
          done
